<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="keywords" content="段高华的个人博客,段高华,个人博客,DGH"><meta name="description" content="段高华的个人博客，用来分享感悟，交流技术"><meta name="google-site-verification" content="QrUYVxCv1Bj4G1bn_SOjQmEVgJVpWZvtzbtXUbj6IkQ"><meta name="baidu-site-verification" content="0sZAwJdLy1"><title>MySQL高级特性 | DGH</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL高级特性</h1><a id="logo" href="/.">DGH</a><p class="description">真正有思想的人是有趣的</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL高级特性</h1><div class="post-meta">Sep 2, 2018<span class="article-traffic" id="busuanzi_container_page_pv" style="padding-left: 15px;">本文阅读量<span id="busuanzi_value_page_pv"></span> 次</span></div><a class="ds-thread-count" href="/mysql-part7.html#SOHUCS"><span id="changyan_count_unit" style="font-size: 15px; color: #6E7173;">0</span><span> 条评论</span></a><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js" async></script><div class="post-content"><ol>
<li><p>分区表</p>
<ol>
<li><p>概念<br>分区表是一种粗粒度的、简易的索引策略，适用于大数据量的过滤场景。对用户来说，分区表是一个独立的逻辑表，但是底层是由多个物理子表组成。</p>
</li>
<li><p>使用场景<br>表的数据非常大以致无法全部放到内存中，或者只在表的最后部分有热点数据，其他均是历史数据<br>分区表的数据更容易维护。可以删除整个分区，对单独分区优化<br>分区表的数据可以存储在不同的物理设备，有效的利用多个硬件设备<br>可以使用分区表避免某些特殊的瓶颈，例如InoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等。</p>
</li>
<li>自身限制<ol>
<li>一个表只能1024个分区</li>
<li>在MySQL5.1中，分区表达必须是整数，或者是返回整数的表达式，MySQL5.5中，某些场景中可以直接使用列进行分区。</li>
<li>如果分区字段中有主键或者唯一索引，那么所有主键列和唯一索引列都必须包含进来。（即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。）</li>
<li>分区表中无法使用外健约束</li>
</ol>
</li>
<li>使用策略<ol>
<li>全量扫描数据， 不要任何索引</li>
<li>索引数据, 分离热点</li>
</ol>
</li>
<li>分区表使用注意场景<ol>
<li>NULL值会使分区过滤无效</li>
<li>分区列和索引列不匹配</li>
<li>选择分区的成本可能很高</li>
<li>打开并锁住所有底层表的成本可能很高</li>
<li>维护分区的成本可能很高</li>
<li>所有分区表必须使用相同的存储引擎</li>
<li>MERGE, CSV, or FEDERATED存储引擎不支持分区</li>
</ol>
</li>
<li>查询优化<ol>
<li>分区表最大的优点就是优化器可以根据分区函数过滤一些分区。根据粗粒度索引的优势，通过分区过滤通常可以让查询扫描更少的数据。</li>
<li>在WHERE条件中带入分区列，有时候即使看似多余也要带上，可以让优化器过滤掉无需访问的分区</li>
</ol>
</li>
<li>分区表类型<ul>
<li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。<ol>
<li>当插入的记录中对应的分区键的值不在分区定义的范围中的时候，插入语句会失败</li>
<li>Range分区中，分区键的值如果是NULL，将被作为一个最小值来处理。</li>
</ol>
</li>
<li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。<ol>
<li>如果插入的记录对应的分区键的值不在list分区指定的值中，将会插入失败。并且，list不能像range分区那样提供maxvalue。</li>
</ol>
</li>
<li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。</li>
<li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li>
<li>COLUMN分区是5.5开始引入的分区功能，只有RANGE COLUMN和LIST COLUMN这两种分区；支持整形、日期、字符串；RANGE和LIST的分区方式非常的相似。</li>
</ul>
</li>
<li><p>分区表相关命令</p>
<ul>
<li><p>查看是否支持分区表</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW PLUGINS ;</span><br><span class="line">#如果 partition 的状态是ACTIVE 表示支持分区表</span><br><span class="line">partition                  | ACTIVE</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建RANGE分区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees ( </span><br><span class="line">    id INT NOT NULL, </span><br><span class="line">    fname VARCHAR(30), </span><br><span class="line">    lname VARCHAR(30), </span><br><span class="line">    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;, </span><br><span class="line">    separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;, </span><br><span class="line">    job_code INT NOT NULL, </span><br><span class="line">    store_id INT NOT NULL </span><br><span class="line">) </span><br><span class="line">PARTITION BY RANGE (store_id) ( </span><br><span class="line">    PARTITION p0 VALUES LESS THAN (6), </span><br><span class="line">    PARTITION p1 VALUES LESS THAN (11), </span><br><span class="line">    PARTITION p2 VALUES LESS THAN (16), </span><br><span class="line">    PARTITION p3 VALUES LESS THAN (21) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建LIST分区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tblist (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line">PARTITION BY LIST(store_id) (</span><br><span class="line">    PARTITION a VALUES IN (1,5,6),</span><br><span class="line">    PARTITION b VALUES IN (2,7,8),</span><br><span class="line">    PARTITION c VALUES IN (3,9,10),</span><br><span class="line">    PARTITION d VALUES IN (4,11,12)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建HASH分区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tblinhash (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;</span><br><span class="line">)</span><br><span class="line">PARTITION BY LINEAR HASH( YEAR(hired) )</span><br><span class="line">PARTITIONS 6;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建KEY分区</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb_key (</span><br><span class="line">    id INT ,</span><br><span class="line">    var CHAR(32) </span><br><span class="line">)</span><br><span class="line">PARTITION BY KEY(var)</span><br><span class="line">PARTITIONS 10;</span><br><span class="line">range column</span><br><span class="line">CREATE TABLE members (</span><br><span class="line">    id INT,</span><br><span class="line">    joined DATE NOT NULL</span><br><span class="line">)</span><br><span class="line">PARTITION BY RANGE COLUMNS(joined) (</span><br><span class="line">    PARTITION a VALUES LESS THAN (&apos;1960-01-01&apos;),</span><br><span class="line">    PARTITION b VALUES LESS THAN (&apos;1970-01-01&apos;),</span><br><span class="line">    PARTITION c VALUES LESS THAN (&apos;1980-01-01&apos;),</span><br><span class="line">    PARTITION d VALUES LESS THAN (&apos;1990-01-01&apos;),</span><br><span class="line">    PARTITION e VALUES LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除表的分区</p>
<ul>
<li>使用remove移除分区是仅仅移除分区的定义，并不会删除数据和drop PARTITION不一样，后者会连同数据一起删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename</span><br><span class="line">REMOVE PARTITIONING ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>demo</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  CREATE TABLE employees (</span><br><span class="line">      id INT NOT NULL,</span><br><span class="line">      fname VARCHAR(30),</span><br><span class="line">      lname VARCHAR(30),</span><br><span class="line">      hired DATE NOT NULL DEFAULT &apos;1970-01-01&apos;,</span><br><span class="line">      separated DATE NOT NULL DEFAULT &apos;9999-12-31&apos;,</span><br><span class="line">      job_code INT NOT NULL,</span><br><span class="line">      store_id INT NOT NULL</span><br><span class="line">  )</span><br><span class="line">  PARTITION BY RANGE (store_id) (</span><br><span class="line">      PARTITION p0 VALUES LESS THAN (6),</span><br><span class="line">      PARTITION p1 VALUES LESS THAN (11),</span><br><span class="line">      PARTITION p2 VALUES LESS THAN (16),</span><br><span class="line">      PARTITION p3 VALUES LESS THAN (21)</span><br><span class="line">  );</span><br><span class="line">##查看分区情况</span><br><span class="line">SELECT   PARTITION_NAME, PARTITION_METHOD, PARTITION_EXPRESSION, PARTITION_DESCRIPTION,TABLE_ROWS,SUBPARTITION_NAME,SUBPARTITION_METHOD,SUBPARTITION_EXPRESSION FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA=SCHEMA() AND TABLE_NAME=&apos;employees&apos;;</span><br><span class="line">### 创建索引</span><br><span class="line">alter table employees add index ix_store_id(store_id) ;</span><br><span class="line">alter table employees add index ix_job_code(job_code) ;</span><br><span class="line"></span><br><span class="line">###插入数据</span><br><span class="line">insert into employees(id,job_code,store_id) values(1,1001,1),(2,1002,2),(3,1003,3),(4,1004,4);</span><br><span class="line"></span><br><span class="line">###比较效果</span><br><span class="line">explain select * from employees where store_id = 3;</span><br><span class="line">explain select * from employees where store_id &lt; 11;</span><br><span class="line">##超过分区范围提示错误</span><br><span class="line">insert into employees(id,job_code,store_id) values(1,1001,33);</span><br><span class="line">##增加新分区</span><br><span class="line">alter table employees add PARTITION  (PARTITION p4 VALUES LESS THAN MAXVALUE);</span><br><span class="line">##删除分区</span><br><span class="line">alter table employees drop  PARTITION p4;</span><br><span class="line">##拆分分区</span><br><span class="line">ALTER TABLE employees REORGANIZE PARTITION p0 INTO (</span><br><span class="line">    PARTITION s0 VALUES LESS THAN (3),</span><br><span class="line">    PARTITION s1 VALUES LESS THAN (6)</span><br><span class="line">);</span><br><span class="line">##移除分区</span><br><span class="line">ALTER TABLE employees</span><br><span class="line">REMOVE PARTITIONING ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>合并表</p>
<ol>
<li>概念<br>合并表是一种早期的、简单的分区实现，和分区表相比有一些不同的限制，并且缺乏优化。（一种将被淘汰的技术，在未来的版本中可能被删除），合并表和merge引擎</li>
<li>和分区表的区别<br>合并表允许用户单独访问各个子表，分区表对用户来说是一个独立的逻辑表<br>分区表和优化器的结合更加紧密，</li>
<li>合并表的不足<br>合并表中的每一个子表行为和定义都是相同的，但是合并表在全局上并不接受这些条件限制<br>查询访问合并表，需要访问所有子表。而分区表能根据查询条件过滤部分分区</li>
</ol>
</li>
</ol>
</li>
<li><p>字符集和校对</p>
<ol>
<li>字符集概念<br>基本概念<ol>
<li>字符(Character)是指人类语言中最小的表义符号。例如’A’、’B’等；</li>
<li>给定一系列字符，对每个字符赋予一个数值，用数值来代表对应的字符，这一数值就是字符的编码(Encoding)。例如，我们给字符’A’赋予数值0，给字符’B’赋予数值1，则0就是字符’A’的编码；</li>
<li>给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合就是字符集(Character Set)。例如，给定字符列表为{’A’,’B’}时，{’A’=&gt;0, ‘B’=&gt;1}就是一个字符集；</li>
<li>字符序(Collation)是指在同一字符集内字符之间的比较规则；</li>
<li>确定字符序后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系；</li>
<li>每个字符序唯一对应一种字符集，但一个字符集可以对应多种字符序，其中有一个是默认字符序(Default Collation)；</li>
<li>MySQL中的字符序名称遵从命名惯例：以字符序对应的字符集名称开头；以_ci(表示大小写不敏感)、_cs(表示大小写敏感)或_bin(表示按编码值比较)结尾。例如：在字符序“utf8_general_ci”下，字符“a”和“A”是等价的；</li>
</ol>
</li>
<li><p>系统变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">character_set_server：默认的内部操作字符集</span><br><span class="line">character_set_client：客户端来源数据使用的字符集</span><br><span class="line">character_set_connection：连接层字符集</span><br><span class="line">character_set_results：查询结果字符集</span><br><span class="line">character_set_database：当前选中数据库的默认字符集</span><br><span class="line">character_set_system：系统元数据(字段名等)字符集</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关命令</p>
<ol>
<li>查看系统支持字符集<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW CHARACTER SET; #查看支持字符集</span><br><span class="line">SHOW COLLATION;     #查看支持校验</span><br><span class="line">show variables like &apos;collation_%&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>    2. 设置系统字符集
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET character_set_client = utf8 ;  </span><br><span class="line">SET character_set_connection = utf8 ;   </span><br><span class="line">SET character_set_database = utf8 ;   </span><br><span class="line">SET character_set_results = utf8 ;    </span><br><span class="line">SET character_set_server = utf8 ;  </span><br><span class="line"></span><br><span class="line">SET collation_connection = utf8 ;  </span><br><span class="line">SET collation_database = utf8 ;   </span><br><span class="line">SET collation_server = utf8 ; </span><br><span class="line">######### SET NAMES 命令相当与执行了  character_set_client， character_set_connection，character_set_results</span><br><span class="line">SET NAMES UTF8</span><br></pre></td></tr></table></figure>

    3. 查看系统字符集
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &apos;character%&apos;;</span><br><span class="line">STATUS;</span><br></pre></td></tr></table></figure>

    4. 查看表的默认字符集
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. show create table `t1`;</span><br></pre></td></tr></table></figure>

    5. 设置表的字符集
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table `t1` charset=gbk;</span><br></pre></td></tr></table></figure>

    6. 查看字段字符集
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show full columns from t1;</span><br></pre></td></tr></table></figure>

    7. 修改字段字符集
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t1 change `name`  `name` varchar(20) character set utf8  COLLATE utf8_bin not null default &apos;&apos;;</span><br></pre></td></tr></table></figure>

4. 字符集继承顺序
    1. SERVER-&gt;DB-&gt;TABLE-&gt;COLUMN
5. 注意点  
    1. character_set_client 字符集要和客户端字符集保持一致，否者多字节字符会出现乱码
    2. LENGTH函数和CHAR_LENGTH函数的区别LENGTH计算字符数，CHAR_LENGTH计算字节数,多字节字符这两个函数的结果会不一样
    3. 字符集会影响临时表的分配UTF8字符集会按最大字节数分配就算存的全是字母，也是按每个字符三个字节分配
    4. 影响索引的最长索引前缀（不同版本的MySQL最长索引前缀不同，单位按字节算）
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t2 (</span><br><span class="line">    id int not null auto_increment primary key, </span><br><span class="line">    `name` varchar(1025) not null default &apos;&apos;, </span><br><span class="line">    key(`name`)</span><br><span class="line">) engine=innodb charset =utf8;</span><br><span class="line">ERROR 1071 (42000): Specified key was too long; max key length is 3072 bytes</span><br></pre></td></tr></table></figure>

3. 绑定变量
    1. 使用场合  
    当查询语句的解析和执行计划生成消耗了主要的时间，那么绑定变量可以在一定程度上解决问题，因为只需要解析一次，对于大量重复类型的查询语句，
    性能会有很大的提高。
    2. 高效的原因
        1. 在服务端只需要解析一次  
        2. 在服务端的某些优化器的工作只需要执行一次，因为会缓存一部分执行计划。
        3. 一二进制的方式只发送参数和句柄， 比起每次都发送ASCII码文本效率高，一个二进制的日期只需要三个字节，但如果是ASCII码则需要十个字节
        4. 仅仅是参数----而不是整个查询语句----需要发送到服务器，所以网络开销会更小。
        5. MySQL在存储参数的时候，直接将其存放在缓存中，不再需要在内存中多次复制
    3. 绑定变量安全性相对较高（任何时候都不要相信用户的数据，即使是绑定变量）
        1. 无需在应用程序中处理转义，操作更简便，大大减少了SQL注入和攻击的风险
    4. 绑定变量的优化
        1. 准备阶段  
        服务器解析SQL语句，移除不可能的条件，并且重写子查询
        2. 在第一次执行的时候  
        如果可能， 服务器先简化嵌套循环的关联，并将外关联转化成内关联
        3. 在每次SQL语句执行时  
            1. 过滤分区
            2. 如果可能的话， 尽量移除COUNT(),MIN(),MAX()
            3. 移除常量表达式
            4. 检测常量表
            5. 做必要的等值传播
            6. 分析和优化ref、 range和索引优化等访问数据的方式
            7. 优化关联顺序
        4. 绑定变量的限制
            1. 绑定变量是会话级别的，所以连接之间不能共用绑定句柄，一旦连接断开，原来的句柄就不能使用（连接池和持久连接一定程度上缓解这个问题）
            2. 在MySQL5.1之前不能使用查询缓存
            3. 如果只是执行一次SQL，那么使用绑定变量的方式无疑比直接执行多了一次额外的准备阶段消耗，还需要一次额外的网络开销
            4. 如果总是忘记释放绑定变量资源，服务器很容易发生资源泄漏，绑定变量的SQL总数是一个全局限制
        5. 相关命令
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET @sql := &apos;select * from `t1` where `name` = ?&apos;;</span><br><span class="line">PREPARE stmt_fetch FROM @sql;</span><br><span class="line">SET @name :=&apos;a&apos;;</span><br><span class="line">EXECUTE stmt_fetch USING @name;</span><br></pre></td></tr></table></figure>
</code></pre></div><div class="tags"><a href="/tags/高性能MySQL/">高性能MySQL</a></div><div class="post-nav"><a class="next" href="/mysql-part6.html">查询性能优化</a></div><div id="SOHUCS" sid="1535886231000"></div><script>(function(){var appid='cytKTcg6f';var conf='prod_9a90befaebddcefc490b20caebf42468';var width=window.innerWidth||document.documentElement.clientWidth;if(width<960){window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+appid+'&conf='+conf+'"><\/script>')}else{var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})})}})()
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.beere.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/高性能MySQL/" style="font-size: 15px;">高性能MySQL</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/mysql-part7.html">MySQL高级特性</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part6.html">查询性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part5.html">创建高性能的索引</a></li><li class="post-list-item"><a class="post-list-link" href="/sort.html">排序算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part4.html">Schema 与数据类型优化</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part3.html">服务器性能剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part2.html">MySQL基准测试</a></li><li class="post-list-item"><a class="post-list-link" href="/redis1.html">关于Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part1.html">MySQL架构与历史</a></li><li class="post-list-item"><a class="post-list-link" href="/gantt.html">XMind 8免费激活方法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">DGH.</a> Powered by<a rel="external nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="external nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="external nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><br/><span class="article-traffic" id="busuanzi_container_site_pv">本站总访问量&nbsp;<span id="busuanzi_value_site_pv"></span> 次&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="article-traffic" id="busuanzi_container_site_uv">本站访客数&nbsp;<span id="busuanzi_value_site_uv"></span> 人次</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>