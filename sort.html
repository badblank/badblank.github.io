<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="keywords" content="段高华的个人博客,段高华,个人博客,DGH"><meta name="description" content="段高华的个人博客，用来分享感悟，交流技术"><meta name="google-site-verification" content="QrUYVxCv1Bj4G1bn_SOjQmEVgJVpWZvtzbtXUbj6IkQ"><meta name="baidu-site-verification" content="0sZAwJdLy1"><title>排序算法总结 | DGH</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">排序算法总结</h1><a id="logo" href="/.">DGH</a><p class="description">真正有思想的人是有趣的</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">排序算法总结</h1><div class="post-meta">Aug 14, 2018<span class="article-traffic" id="busuanzi_container_page_pv" style="padding-left: 15px;">本文阅读量<span id="busuanzi_value_page_pv"></span> 次</span></div><a class="ds-thread-count" href="/sort.html#SOHUCS"><span id="changyan_count_unit" style="font-size: 15px; color: #6E7173;">0</span><span> 条评论</span></a><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js" async></script><div class="post-content"><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，故因此得名<br>举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序，首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6.同理4和8交换，变成5,3,4,8,6.<br>3和4无需交换。5和3交换，变成3,5,4,8,6,3. 这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列一次冒泡就会得到一个有序序列。<br>冒泡的时间复杂度为O(n^2)<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function bubbleSort($arr)&#123;</span><br><span class="line">    if(empty($arr))</span><br><span class="line">        return;</span><br><span class="line">    for(int $i=0; $i &lt; count($arr); $i++) &#123;         // 每次最大元素就像气泡一样&quot;浮&quot;到数组的最后</span><br><span class="line">        for(int $j = count($arr)-1; $j&gt;$i; $j--)&#123;   // 依次比较相邻的两个元素,使较大的那个向后移</span><br><span class="line">            if($arr[$j] &lt; $arr[$j-1])&#123;              // 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法</span><br><span class="line">                int $tmp = $arr[$i];</span><br><span class="line">                $arr[$i] = $arr[$j];</span><br><span class="line">                $arr[$j] = $tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换，而选择排序是通过对整体的选择。<br>举个栗子，对 5,3,8,6,4 这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。<br>其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。<br>选择排序的时间复杂度为O(n^2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function selectSort( $arr )&#123;</span><br><span class="line">    if( empty($arr) )</span><br><span class="line">        return;</span><br><span class="line">    int $minIndex = 0;</span><br><span class="line">    for(int $i=0; $i &lt; count($arr)-1; $i++)&#123; //只需要比较n-1次</span><br><span class="line">        $minIndex = i;</span><br><span class="line">        for(int $j=$i+1; $j &lt; count($arr); $j++)&#123; // 从i+1开始比较，因为minIndex默认为i了，i就没必要比了</span><br><span class="line">            if($arr[$j] &lt; $arr[$minIndex]) &#123;</span><br><span class="line">                $minIndex = $j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if($minIndex != $i)&#123;</span><br><span class="line">            int $tmp = $arr[$i];</span><br><span class="line">            $arr[$i] = $arr[$minIndex];</span><br><span class="line">            $arr[$minIndex] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。<br>举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。<br>简单插入排序的时间复杂度也是O(n^2)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function InsertSort( $arr )&#123;</span><br><span class="line">    if( empty($arr) )</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    for(int $i = 1; $i &lt; count($arr); $i++)&#123; </span><br><span class="line">        int $j = $i;</span><br><span class="line">        int $target = $arr[$i]; // 待插入的</span><br><span class="line">        // 后移</span><br><span class="line">        while($j&gt;0 &amp;&amp; $target &lt; $arr[$j-1])&#123;</span><br><span class="line">            $arr[$j] = $arr[$j-1];</span><br><span class="line">            $j--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入</span><br><span class="line">        $arr[$j] = $target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>首先我们要理解一下快速排序的原理：找到当前数组中的任意一个元素（一般选择第一个元素），作为标准，新建两个空数组，遍历整个数组元素，<br>如果遍历到的元素比当前的元素要小，那么就放到左边的数组，否则放到右面的数组，然后再对新数组进行同样的操作<br>不难发现，这里符合递归的原理，所以我们可以用递归来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function quick_sort( $arr )&#123;</span><br><span class="line">    // 判断参数是否是一个数组</span><br><span class="line">    if( !is_array( $arr ) )</span><br><span class="line">        return false;</span><br><span class="line">    $length = count( $arr );</span><br><span class="line">    if( $length&lt;=1 )</span><br><span class="line">        return $arr;</span><br><span class="line">    // 数组元素有多个，则定义两个空数组</span><br><span class="line">    $left = $right = array();</span><br><span class="line">    </span><br><span class="line">    // 使用for循环进行遍历，把第一个元素当做比较的对象</span><br><span class="line">    for( $i=1; $i&lt;$length; $i++)&#123;</span><br><span class="line">        //判断当前元素的大小</span><br><span class="line">        if( $arr[$i]&lt;$arr[0] )&#123;</span><br><span class="line">            $left[]  = $arr[$i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $right[] = $arr[$i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归调用</span><br><span class="line">    $left   = quick_sort($left);</span><br><span class="line">    $right  = quick_sort($right);</span><br><span class="line">    </span><br><span class="line">    // 将所有的结果合并        </span><br><span class="line">    return array_merge($left, $arr[0], $right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/mysql-part5.html">创建高性能的索引</a><a class="next" href="/mysql-part4.html">Schema 与数据类型优化</a></div><div id="SOHUCS" sid="1534228818000"></div><script>(function(){var appid='cytKTcg6f';var conf='prod_9a90befaebddcefc490b20caebf42468';var width=window.innerWidth||document.documentElement.clientWidth;if(width<960){window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+appid+'&conf='+conf+'"><\/script>')}else{var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})})}})()
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.beere.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/高性能MySQL/" style="font-size: 15px;">高性能MySQL</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/mysql-part7.html">MySQL高级特性</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part6.html">查询性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part5.html">创建高性能的索引</a></li><li class="post-list-item"><a class="post-list-link" href="/sort.html">排序算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part4.html">Schema 与数据类型优化</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part3.html">服务器性能剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part2.html">MySQL基准测试</a></li><li class="post-list-item"><a class="post-list-link" href="/redis1.html">关于Redis</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql-part1.html">MySQL架构与历史</a></li><li class="post-list-item"><a class="post-list-link" href="/gantt.html">XMind 8免费激活方法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">DGH.</a> Powered by<a rel="external nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="external nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="external nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><br/><span class="article-traffic" id="busuanzi_container_site_pv">本站总访问量&nbsp;<span id="busuanzi_value_site_pv"></span> 次&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="article-traffic" id="busuanzi_container_site_uv">本站访客数&nbsp;<span id="busuanzi_value_site_uv"></span> 人次</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>